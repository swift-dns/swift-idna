#!/usr/bin/env swift

import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

let mappingTableURL = "https://www.unicode.org/Public/idna/17.0.0/IdnaMappingTable.txt"
let outputPath = "Sources/CSwiftIDNA/src/cswift_idna_mapping_table.c"

func codePointsRangeText(_ codePoint1: UInt32, _ codePoint2: UInt32?) -> String {
    if let codePoint2 = codePoint2 {
        return "{ \(codePoint1), \(codePoint2) }"
    } else {
        return "{ \(codePoint1), \(codePoint1) }"
    }
}

func fetchWithRetries(url: URL) throws -> Data {
    let maxAttempts = 5
    for attempts in 1...maxAttempts {
        do {
            return try Data(contentsOf: url)
        } catch {
            if attempts == maxAttempts {
                throw error
            } else {
                print("âœ— Failed to fetch latest release: \(String(reflecting: error))")
                print("Retrying in 3 seconds...")
                sleep(3)
            }
        }
    }
    fatalError("Unreachable")
}

func generate() -> String {
    let currentDirectory = FileManager.default.currentDirectoryPath
    guard currentDirectory.hasSuffix("swift-idna") else {
        fatalError(
            "This script must be run from the swift-idna root directory. Current directory: \(currentDirectory)."
        )
    }

    print("Downloading \(mappingTableURL) ...")
    let file = try! fetchWithRetries(url: URL(string: mappingTableURL)!)
    print("Downloaded \(file.count) bytes")

    let utf8String = String(decoding: file, as: UTF8.self)

    // Parse the mapping table to build ranges
    var entries: [(start: UInt32, end: UInt32)] = []

    for line in utf8String.split(separator: "\n") {
        var line = line.trimmingWhitespaces()

        if line.first == "#" { continue }
        if line.isEmpty { continue }

        if let trailingCommentIndex = line.reversed().firstIndex(of: "#") {
            let endIndex = line.index(trailingCommentIndex.base, offsetBy: -1)
            line = line[..<endIndex].trimmingWhitespaces()
        }

        let parts = line.split(
            separator: ";",
            omittingEmptySubsequences: false
        )
        guard parts.count >= 2 else {
            fatalError("Line has less than 2 parts: \(line.debugDescription)")
        }
        let targetCodePoints = parts[0].trimmingWhitespaces().split(separator: "..")
        let codePoint1 = UInt32(targetCodePoints[0], radix: 16)!
        var codePoint2: UInt32?
        switch targetCodePoints.count {
        case 1: break
        case 2:
            codePoint2 = UInt32(targetCodePoints[1], radix: 16)!
        default:
            fatalError(
                "Unexpected amount of target code points: \(targetCodePoints.count), line: \(line.debugDescription)"
            )
        }

        let end = codePoint2 ?? codePoint1
        entries.append((start: codePoint1, end: end))
    }

    // Find the actual maximum code point from the data
    let maxCodePoint = entries.map { $0.end }.max() ?? 0x10FFFF
    var lookupTable: [UInt32] = Array(repeating: 0, count: Int(maxCodePoint + 1))

    print(
        "Building lookup table for \(maxCodePoint + 1) code points (max from data: 0x\(String(maxCodePoint, radix: 16, uppercase: true)))"
    )

    // Fill the lookup table efficiently by iterating through ranges
    var currentIndex = 0
    for codePoint in 0...maxCodePoint {
        // Find the appropriate range for this code point
        while currentIndex < entries.count && codePoint > entries[currentIndex].end {
            currentIndex += 1
        }

        // If we found a range that contains this code point, use it
        if currentIndex < entries.count && codePoint >= entries[currentIndex].start
            && codePoint <= entries[currentIndex].end
        {
            lookupTable[Int(codePoint)] = UInt32(currentIndex)
        } else {
            // Default to first entry (should be the catch-all entry)
            lookupTable[Int(codePoint)] = 0
        }
    }

    var generatedCode = """
        // This file is generated by the utils/IDNAMappingTableGenerator.swift script.
        // It contains the IDNA mapping table data in C, since Swift cannot handle the large lookup table.

        #include "../include/CSwiftIDNA.h"
        #include <stdint.h>
        #include <stddef.h>

        #define CSWIFT_UNICODE_MAX_CODE_POINT 0x10FFFFU

        static const CSwiftIDNAMappingResult cswift_idna_mapping_table[];
        static const uint32_t cswift_idna_lookup_table[CSWIFT_UNICODE_MAX_CODE_POINT + 1];

        const CSwiftIDNAMappingResult* cswift_idna_mapping_lookup(uint32_t code_point) {
            uint32_t index = cswift_idna_lookup_table[code_point];
            return &cswift_idna_mapping_table[index];
        }

        static const CSwiftIDNAMappingResult cswift_idna_mapping_table[] = {

        """

    // Reset to parse again for the actual table generation
    for line in utf8String.split(separator: "\n") {
        var line = line.trimmingWhitespaces()

        if line.first == "#" { continue }
        if line.isEmpty { continue }

        if let trailingCommentIndex = line.reversed().firstIndex(of: "#") {
            let endIndex = line.index(trailingCommentIndex.base, offsetBy: -1)
            line = line[..<endIndex].trimmingWhitespaces()
        }

        let parts = line.split(
            separator: ";",
            omittingEmptySubsequences: false
        )
        guard parts.count >= 2 else {
            fatalError("Line has less than 2 parts: \(line.debugDescription)")
        }

        let status = parts[1].trimmingWhitespaces()
        switch status {
        case "valid":
            var idna2008Status: String = "IDNA_STATUS_NONE"
            switch parts.count {
            case 2:
                idna2008Status = "IDNA_STATUS_NONE"
            case 4:
                let statusStr = parts[3].trimmingWhitespaces()
                switch statusStr {
                case "NV8": idna2008Status = "IDNA_STATUS_NV8"
                case "XV8": idna2008Status = "IDNA_STATUS_XV8"
                default: idna2008Status = "IDNA_STATUS_NONE"
                }
            default:
                fatalError("Unexpected amount of parts for 'valid', line: \(line.debugDescription)")
            }
            generatedCode +=
                "    { IDNA_RESULT_VALID, \(idna2008Status), NULL, 0 },\n"
        case "mapped":
            let mappingParts = parts[2].split(whereSeparator: \.isWhitespace)
            let mappings = mappingParts.map {
                UInt32($0.trimmingWhitespaces(), radix: 16)!
            }
            let mappingArray = mappings.map { "\($0)U" }.joined(separator: ", ")
            let mappingString = mappings.isEmpty ? "NULL" : "(const uint32_t[]){ \(mappingArray) }"
            generatedCode +=
                "    { IDNA_RESULT_MAPPED, IDNA_STATUS_NONE, \(mappingString), \(mappings.count) },\n"
        case "deviation":
            var mappings: [UInt32] = []
            if parts.count > 2 {
                let mappingParts = parts[2].split(whereSeparator: \.isWhitespace)
                mappings = mappingParts.map {
                    UInt32($0.trimmingWhitespaces(), radix: 16)!
                }
            }
            let mappingArray = mappings.map { "\($0)U" }.joined(separator: ", ")
            let mappingString = mappings.isEmpty ? "NULL" : "(const uint32_t[]){ \(mappingArray) }"
            generatedCode +=
                "    { IDNA_RESULT_DEVIATION, IDNA_STATUS_NONE, \(mappingString), \(mappings.count) },\n"
        case "disallowed":
            guard parts.count == 2 else {
                fatalError(
                    "Unexpected amount of parts for 'disallowed', line: \(line.debugDescription)"
                )
            }
            generatedCode +=
                "    { IDNA_RESULT_DISALLOWED, IDNA_STATUS_NONE, NULL, 0 },\n"
        case "ignored":
            guard parts.count == 2 else {
                fatalError(
                    "Unexpected amount of parts for 'ignored', line: \(line.debugDescription)"
                )
            }
            generatedCode +=
                "    { IDNA_RESULT_IGNORED, IDNA_STATUS_NONE, NULL, 0 },\n"
        default:
            fatalError(
                "Unexpected status: \(status.debugDescription), line: \(line.debugDescription)"
            )
        }
    }

    // Generate the lookup table
    generatedCode += """
        };

        // Maps code point to index in cswift_idna_mapping_table for O(1) lookups.
        static const uint32_t cswift_idna_lookup_table[CSWIFT_UNICODE_MAX_CODE_POINT + 1] = {

        """

    print("Writing lookup table...")

    // Write the lookup table in chunks to avoid line length issues
    let chunkSize = 16
    for i in stride(from: 0, to: lookupTable.count, by: chunkSize) {
        let end = min(i + chunkSize, lookupTable.count)
        let chunk = lookupTable[i..<end].map { "\($0)U" }.joined(separator: ", ")
        generatedCode += "    \(chunk)"
        if end < lookupTable.count {
            generatedCode += ","
        }
        generatedCode += "\n"
    }

    generatedCode += """
        };

        """

    return generatedCode
}

extension StringProtocol {
    func trimmingWhitespaces() -> String {
        String(
            String(
                self
                    .trimmingPrefix(while: \.isWhitespace)
                    .reversed()
            )
            .trimmingPrefix(while: \.isWhitespace)
            .reversed()
        )
    }
}

let text = generate()
print("Generated \(text.split(whereSeparator: \.isNewline).count) lines")

if FileManager.default.fileExists(atPath: outputPath),
    try! String(contentsOfFile: outputPath, encoding: .utf8) == text
{
    print("Generated code matches current contents, no changes needed.")
} else {
    print("Writing to \(outputPath) ...")
    try! text.write(toFile: outputPath, atomically: true, encoding: .utf8)
}

print("Done!")
